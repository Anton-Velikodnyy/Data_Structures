/*
 *	Created by Anton Velikodnyy & edited by Daniel Tellier on 6/27/17.
 *	CopyrightChild Â© 2017 Anton Velikodnyy. All rightChilds reserved.
 *	May be distributed for the use of teaching purposes.
 */

/**
 *	Container for the storage of data given.
 *	{@code Node} contains the pointer to the next instances in the tree of
 *	nodes generated by {@BST}.
 *	<p>
 *	Note, requires {@code extends Comparable} because < and > are used to compare
 *	generic objects
 */
class Node<U extends Comparable<U>>  {
	
	/**
	 *	Stores a generic immutable object.
	 */
	protected final U data;
	
	/**
	 *	Stores value for structure organization.
	 */
	protected int height;
	
	/**
	 *	Pointer to the leftChild child node of this node in the tree.
	 */
	protected  Node<U> leftChild;
	
	/**
	 *	Pointer to the rightChild child node of this node in the tree.
	 */
	protected  Node<U> rightChild;
	
	//----------------------------------------------------------------------------
	/**
	 *	Constructor of this {@code Node} class.
	 *
	 *	@param data  takes given object and stores in this Node.
	 */
	protected Node (U data)  {
		this.data = data;
	}
	
	/**
	 *	Prints the data that is stored in this Node.
	 *
	 *	@return data in string form.
	 */
	@Override
	public String toString ()  {
		return data.toString();
	}
	
}

/**
 *	BST is an object which creates and manages a tree of nodes stored
 *	in memory.
 *	<p>
 *	This class accepts any data type and can only directly access the
 *	head of the tree of nodes it manages.
 *	<p>
 *	Note, requires {@code extends Number} because < and > are used to compare
 *	generic objects
 */
public class BST<T extends Comparable<T>>  {
	
	
	//----------------------------------------------------------------------------
	/**
	 *	Stores pointer to starting Node of the tree.
	 */
	private Node<T> headNode = null;
	
	//----------------------------------------------------------------------------
	/**
	 *	Inserts Node into the tree.
	 *	<p>
	 *	If the tree is empty, the following actions occur:
	 *	<p><ol>
	 *	<li>Node instance created.
	 *	<li>This class' headNode becomes a pointer to this Node.
	 *	</ol><p>
	 *	If the tree is not empty, the following actions occur:
	 *	<p><ol>
	 *	<li>tempNode is used to traverse the tree until a place to insert a new Node
	 *	is found.
	 *	<li>A new Node is created and tempNode's child now points to this new Node
	 *	</ol><p>
	 *
	 *	@param data  is an Object, who's data-type matches the initially declared
	 *	data-type of this class, to be stored.
	 */
	public void insert(T data) {
		if (headNode == null) {
			headNode = new Node<T>(data);
			return;
		}
		Node<T> parent = null, tempNode = headNode;
		int comparisonResult;
		
		while (tempNode != null) {
			parent = tempNode;
			comparisonResult = data.compareTo( tempNode.data );
			
			if      ( comparisonResult < 0 )
				tempNode = tempNode.leftChild;
			else if ( comparisonResult > 0 )
				tempNode = tempNode.rightChild;
			else
				return;
		}
		
		comparisonResult = data.compareTo( parent.data );
		if ( comparisonResult < 0 )
			parent.leftChild  = new Node<T>(data);
		else
			parent.rightChild = new Node<T>(data);
	}
	
	
	//----------------------------------------------------------------------------
	
	//----------------------------------------------------------------------------
	/**
	 *	Selects the Node to be removed, if it matches the search criteria given.
	 *	<p>
	 *	If isEmpty()} is false, the following actions occur.
	 *	<p></ol>
	 *	<li>tempNode is used to traverse the tree to find the match.
	 *	<li>Once match is found, removeNode is called.
	 *	<li>If no match is found, nothing happens.
	 *	</ol><p>
	 *
	 *	@param data  search criteria for the node to be removed.
	 */
	public void remove (T data)  {
		if (headNode == null) {
			return;
		}
		
		Node<T> parent = null, tempNode = headNode;
		int comparisonResult;
		
		while (tempNode != null) {
			comparisonResult = data.compareTo( tempNode.data );
			
			if      ( comparisonResult < 0 )  {
				parent = tempNode;
				tempNode = tempNode.leftChild;
			}
			else if ( comparisonResult > 0 )  {
				parent = tempNode;
				tempNode = tempNode.rightChild;
			}
			else  {
				
				comparisonResult = tempNode.data.compareTo( parent.data );
				
				if			( comparisonResult < 0 )
					parent.leftChild = removeNode ( tempNode );
				else if ( comparisonResult > 0 )
					parent.rightChild = removeNode ( tempNode );
				
				return;
			}
			
		}
	}
	
	/*
	 *	Finds next largest Node that follows this tempNode.
	 *	<p>
	 *	Recurisvely traverses this tree until the ideal node is found.
	 *	Stores the found node in maxNodeTemp and removes it from the tree.
	 *	Returning back through the stack, returns the previous node accessed, and
	 *	any modifications it has recieved, such as a null from the removed Node.
	 *
	 *	@param tempNode  pointer used for traversal of this tree.
	 *	@return tempNode which is the current Node to be traversed.
	 */
	private Node<T> findNextLargest (Node<T> tempNode, Node<T> parent)  {
		
		while (tempNode.leftChild != null) {
			parent   = tempNode;
			tempNode = tempNode.leftChild;
		}
		parent.rightChild = tempNode.rightChild;
		return tempNode;
	}
	
	/*
	 *	Removes the node from the tree.
	 *	<p>
	 *	The first if statement is to establish which child is to be of tempNode
	 *	needs to be removed. (note: Since erasing the pointer directly does not
	 *	break the original pointer)
	 *	<p>
	 *	Three scenarios arise from removing a node
	 *	<p><ol>
	 *	<li>If only the rightNode of the child is null, then leftNode replaces
	 *	the child.
	 *	<li>If both are null, then child becomes null.
	 *	<li>If rightNode is not null, then the next largest Node must be found,
	 *	and is replaces the child.
	 *	<ol><p>
	 *
	 *	@param tempNode  the parent of the node to be removed.
	 *	@param leftChild  boolean that determines if the leftChild or rightChild
	 *	is to be removed
	 *	@return tempNode, the Node that replaces the removed Node.
	 */
	private Node<T> removeNode (Node<T> tempNode) {
		if (tempNode.rightChild == null) {
			if (tempNode.leftChild == null)
				tempNode = null;
			else
				tempNode = tempNode.leftChild;
		}
		
		else if (tempNode.leftChild == null)
			tempNode = tempNode.rightChild;
		
		else {
			Node<T> largerTemp = tempNode.rightChild;
			largerTemp = findNextLargest(largerTemp, tempNode);
			largerTemp.leftChild = tempNode.leftChild;
			tempNode.leftChild = largerTemp;
			largerTemp = tempNode.leftChild.rightChild;
			tempNode.leftChild.rightChild = tempNode.rightChild;
			tempNode = tempNode.leftChild;
		}
		return tempNode;
		
	}
	
	//----------------------------------------------------------------------------
	
	/*
	 *	Clears this tree.
	 */
	public void clear() {
		headNode = null;
	}
	
	//----------------------------------------------------------------------------
	/**
	 *	Checks to see if this class is managing a tree of Nodes.
	 *
	 *	@return true if tree of Nodes exists, false otherwise.
	 */
	private boolean isEmpty () {
		return (headNode == null);
	}
	
	//----------------------------------------------------------------------------
	/**
	 *	Converts the tree of Nodes, through itteration, into a String.
	 *	<p>
	 *	The order of the Node instances are printed in-order, pre-order, and
	 *	post-order.
	 *	<p>
	 *	Returns an emtpy string ("") if tree is empty.
	 *
	 *	@return String that contains all the values in the tree of Nodes.
	 */
	@Override
	public String toString() {
		if (!isEmpty())  {
			
			return "inOrder: "   + inOrder(headNode) + "\n" +
			"preOrder: "  + preOrder(headNode) + "\n" +
			"PostOrder: " + postOrder(headNode);
			
		}
		return "";
	}
	
	public String preOrder (Node<T> tempNode)  {
		if (tempNode != null) {
			return  tempNode + " "+
			preOrder(tempNode.leftChild) +
			preOrder(tempNode.rightChild);
		}
		return "";
	}
	
	public String inOrder (Node<T> tempNode)  {
		if (tempNode != null) {
			System.out.print (tempNode + " ");
			return  inOrder(tempNode.leftChild) +
			tempNode + " " +
			inOrder(tempNode.rightChild);
		}
		return "";
	}
	
	public String postOrder (Node<T> tempNode)  {
		if (tempNode != null) {
			return  inOrder(tempNode.leftChild) +
			inOrder(tempNode.rightChild) +
			tempNode+ " ";
		}
		return "";
	}
	
	//----------------------------------------------------------------------------
	/**
	 *	Tests this BST class for possible errors.
	 *
	 *	@param args  command-line arguments in array form.
	 */
	public static void main (String... args){
		BST<Integer> bst = new BST<Integer>();
		System.out.println ("Inserting 6 \n");
		bst.insert(6);
		System.out.println ("Inserting 2 \n");
		bst.insert(2);
		System.out.println (bst + "\n");
		System.out.println ("Inserting 4 \n");
		bst.insert(4);
		System.out.println (bst + "\n");
		System.out.println ("Inserting 5 \n");
		bst.insert(5);
		System.out.println (bst + "\n");
		System.out.println ("Inserting 3 \n");
		bst.insert(3);
		System.out.println (bst + "\n");
		System.out.println ("Deleting 4 \n");
		bst.remove(4);
		System.out.println (bst + "\n");
		System.out.println ("Inserting 1 \n");
		bst.insert(1);
		System.out.println (bst + "\n");
	}
}

