/*
 *	Created by Anton Velikodnyy & edited by Daniel Tellier on 6/27/17.
 *	CopyrightChild Â© 2017 Anton Velikodnyy. All rightChilds reserved.
 *	May be distributed for the use of teaching purposes.
 */

/**
 *	Container for the storage of data given.
 *	{@code Node} contains the pointer to the next instances in the tree of
 *	nodes generated by {@AVL}.
 *	<p>
 *	Note, requires {@code extends Comparable} because < and > are used to compare
 *	generic objects
 */
import java.util.Arrays;
class Node<U extends Comparable> {
	
	/**
	 *	Stores a generic immutable object.
	 */
	protected final U data;
	/**
	 *	Stores value for structure organization.
	 */
	protected int key;
	
	/**
	 *	Pointer to the leftChild child node of this node in the tree.
	 */
	protected  Node<U> leftChild;
	
	/**
	 *	Pointer to the rightChild child node of this node in the tree.
	 */
	protected  Node<U> rightChild;
	
	//----------------------------------------------------------------------------
	/**
	 *	Constructor of this {@code Node} class.
	 *
	 *	@param data  takes given object and stores in this Node.
	 */
	protected Node (U data) {
		this.data = data;
	}
	
	/**
	 *	Prints the data that is stored in this Node.
	 *
	 *	@return data in string form.
	 */
	@Override
	public String toString () {
		return data.toString();
	}
	
}

/**
 *	AVL is an object which creates and manages a tree of nodes stored
 *	in memory.
 *	<p>
 *	This class accepts any data type and can only directly access the
 *	head of the tree of nodes it manages.
 *	<p>
 *	Note, requires {@code extends Number} because < and > are used to compare
 *	generic objects
 */
public class AVL<T extends Number & Comparable<T>>  {
	
	
	//----------------------------------------------------------------------------
	/**
	 *	Stores pointer to starting Node of the tree.
	 */
	private Node<T> headNode = null;
	
	/**
	 *	Stores pointer for use with removeNode function.
	 */
	private Node<T> maxNodeTemp;
	
	//----------------------------------------------------------------------------
	
	/* 
	 *	Gets key of node.
	 *
	 *	@param tempNode  Node who's key is in question.
	 *	@return key of tempNode or if null, -1.
	 */
	private int getKey (Node<T> tempNode)
	{
		if (tempNode == null)
			return -1;
		else
			return tempNode.key;
	}
	
	/* 
	 *	Gets biggest key between leftChild and rightChild node.
	 *
	 *	@param leftChild  key of the left node.
	 *	@param rightChild  key of the right node.
	 *	@return int of the Child which is bigger
	 */
	private int getMax(int leftChild, int rightChild)
	{
		if (leftChild > rightChild)
			return leftChild;
		else
			return rightChild;
	}
	
	//----------------------------------------------------------------------------
	
	/*
	 *	Rotate binary tree node with left child.
	 *	<p>
	 *	1. Get pointer to leftChild of parent.
	 *	2. Parent's pointer to leftChild becomes the pointer to leftChild's rightChild
	 *	3. leftChild's pointer to rightChild becomes pointer to parent.
	 *	4. Fix height of both nodes. (Parent first, becomse it is now lower in the tree).
	 *
	 *	@param parent  Node to be rotated right.
	 *	@return leftChild which now points to parent.
	 */
	private Node<T> rotateWithLeftChild(Node<T> parent)
	{
		Node<T> leftChild = parent.leftChild;
		
		parent.leftChild = leftChild.rightChild;
		leftChild.rightChild = parent;
		
		parent.key = getMax(getKey(parent.leftChild), getKey(parent.rightChild)) + 1;
		leftChild.key = getMax(getKey(leftChild.leftChild), parent.key) + 1;
		return leftChild;
	}
	
	/*
	 *	Rotate binary tree node with right child
	 *	<p>
	 *	1. Get pointer to rightChild of parent.
	 *	2. Parent's pointer to rightChild becomes the pointer to rightChild's leftChild
	 *	3. rightChild's pointer to leftChild becomes pointer to parent.
	 *	4. Fix height of both nodes. (Parent first, becomse it is now lower in the tree).
	 *
	 *	@param parent  Node to be rotated left.
	 *	@return rightChild which now points to parent.
	 */
	private Node<T> rotateWithRightChild(Node<T> parent)
	{
		Node<T> rightChild = parent.rightChild;
		
		parent.rightChild = rightChild.leftChild;
		rightChild.leftChild = parent;
		
		parent.key = getMax(getKey(parent.leftChild), getKey(parent.rightChild)) + 1;
		rightChild.key = getMax(getKey(rightChild.rightChild), parent.key) + 1;
		return rightChild;
	}
	
	/*
	 *	Balances the Node given.
	 *	<p>
	 *	If this tempNode is null, no need to balance.
	 *	<p>
	 *	Comparison is made between this tempNode's children's keys. 
	 *	If these keys' difference is greater than 1, a rotation is needed to fix tree.
	 *	If a rotation is needed, the childrens' height of Node with bigger key are
	 *	compared. One with the higher key is used to establish the type of rotations
	 *	to undergo.
	 *	<p>
	 *	Rotations are called based on which orientation of nodes fits the if statements.
	 *
	 *	@param tempNode  Node to be balanced.
	 *	@return tempNode which is the node that fits into that location after rotations.
	 */
	private Node<T> balanceNode (Node<T> tempNode) {
		if (tempNode == null)
			return tempNode;
		
		if (getKey (tempNode.leftChild) - getKey (tempNode.rightChild) > 1) {
			if (getKey (tempNode.leftChild.rightChild) > getKey (tempNode.leftChild.leftChild)) {
				tempNode.leftChild = rotateWithRightChild (tempNode.leftChild);
				tempNode = rotateWithLeftChild (tempNode);
			}
			else 
				tempNode = rotateWithLeftChild (tempNode);
		}
		else if (getKey (tempNode.rightChild) - getKey (tempNode.leftChild) > 1) {
			if (getKey (tempNode.rightChild.leftChild) > getKey (tempNode.rightChild.rightChild)) {
				tempNode.rightChild = rotateWithLeftChild (tempNode.rightChild);
				tempNode = rotateWithRightChild (tempNode);
			}
			else
				tempNode = rotateWithRightChild (tempNode);
		}
		
		tempNode.key = getMax(getKey(tempNode.leftChild), getKey(tempNode.rightChild)) + 1;
		return tempNode;
	}
	
	
	//----------------------------------------------------------------------------
	/**
	 *	Inserts data into the tree.
	 *	<p>
	 *	Starts the recursion process for insertion.
	 *
	 *	@param data  is an Object, who's data-type matches the initially declared
	 *	data-type of this class, to be stored.
	 */
	public void insert(T data)
	{
		headNode = insert(data, headNode);
	}
	
	/*
	 *	Insert data through recursion.
	 *	<p>
	 *	Uses recursion to traverse this tree.
	 *	Uses {@code compareTo}, property of Comparable objects, to find which way 
	 *	to traverse through the tree.
	 *	Calls itself either with left or right child based on comparisonResult.
	 *	<p>
	 *	Once the position for the node is found. A new Node is returned.
	 *	<p>
	 *	Returning back through the stack, returns the previous node accessed, and
	 *	any modifications it has recieved, such as a new Node.
	 *
	 *	@param data  the object to be matched.
	 *	@param tempNode  pointer used for traversal of this tree.
	 *	@return tempNode which is the current Node to be traversed.
	 */
	private Node<T> insert(T data, Node<T> tempNode)
	{
		if( tempNode == null )
			return new Node<T>(data);
		
		int comparisonResult = data.compareTo( tempNode.data );
		
		if( comparisonResult < 0 )
			tempNode.leftChild = insert( data, tempNode.leftChild );
		else if( comparisonResult > 0 )
			tempNode.rightChild = insert( data, tempNode.rightChild );
		else;
		
		return balanceNode( tempNode );
	}
	

	
	//----------------------------------------------------------------------------
	/**
	 *	Removes data from the tree.
	 *	<p>
	 *	Starts the recursion process for removal.
	 *
	 *	@param data  is an Object, who's data-type matches the initially declared
	 *	data-type of this class, to be removed.
	 */
	
	/* Function to delete data */
	public void remove(T data)
	{
		headNode = remove(data, headNode);
	}
	
	/*
	 *	Removes data through recursion.
	 *	<p>
	 *	Uses recursion to traverse this tree.
	 *	Uses {@code compareTo}, property of Comparable objects, to find which way
	 *	to traverse through the tree.
	 *	Calls itself either with left or right child based on comparisonResult.
	 *	<p>
	 *	Once the Node matches the key given, this Node is removed.
	 *	<p>
	 *	Returning back through the stack, returns the previous node accessed, and
	 *	any modifications it has recieved, such as a null from the removed Node.
	 *
	 *	@param data  the object to be matched.
	 *	@param tempNode  pointer used for traversal of this tree.
	 *	@return tempNode which is the current Node to be traversed.
	 */
	private Node<T> remove(T data, Node<T> tempNode)
	{
		if( tempNode == null )
			return tempNode;
		
		int comparisonResult = data.compareTo( tempNode.data );
		
		if (comparisonResult < 0)
			tempNode.leftChild = remove (data, tempNode.leftChild);
		else if (comparisonResult > 0)
			tempNode.rightChild = remove (data, tempNode.rightChild);
		else 
			tempNode = removeNode (tempNode);
		
		return balanceNode (tempNode);
	}
	
	/*
	 *	Finds next largest Node that follows this tempNode.
	 *	<p>
	 *	Recurisvely traverses this tree until the ideal node is found.
	 *	Stores the found node in maxNodeTemp and removes it from the tree.
	 *	Returning back through the stack, returns the previous node accessed, and
	 *	any modifications it has recieved, such as a null from the removed Node.
	 *
	 *	@param tempNode  pointer used for traversal of this tree.
	 *	@return tempNode which is the current Node to be traversed.
	 */
	private Node<T> findNextLargest (Node<T> tempNode) {
		if (tempNode.leftChild == null) {
			maxNodeTemp = tempNode;
			tempNode = tempNode.rightChild;
		}
		else
			tempNode.leftChild = findNextLargest(tempNode.leftChild);
		return balanceNode (tempNode);
	}
	
	/*
	 *	Removes the node from the tree.
	 *	<p>
	 *	The first if statement is to establish which child is to be of tempNode
	 *	needs to be removed. (note: Since erasing the pointer directly does not
	 *	break the original pointer)
	 *	<p>
	 *	Three scenarios arise from removing a node
	 *	<p><ol>
	 *	<li>If only the rightNode of the child is null, then leftNode replaces
	 *	the child.
	 *	<li>If both are null, then child becomes null.
	 *	<li>If rightNode is not null, then the next largest Node must be found,
	 *	and is replaces the child.
	 *	<ol><p>
	 *
	 *	@param tempNode  the parent of the node to be removed.
	 *	@param leftChild  boolean that determines if the leftChild or rightChild
	 *	is to be removed
	 *	@return tempNode, the Node that replaces the removed Node.
	 */
	private Node<T> removeNode (Node<T> tempNode) {
		if (tempNode.rightChild == null) {
			if (tempNode.leftChild == null)
				tempNode = null;
			else 
				tempNode = tempNode.leftChild;
		}
		
		else if (tempNode.leftChild == null) 
			tempNode = tempNode.rightChild;
		
		else {
			Node<T> largerTemp = tempNode.rightChild;
			findNextLargest(largerTemp);
			largerTemp = maxNodeTemp;
			maxNodeTemp = null;
			largerTemp.leftChild = tempNode.leftChild;
			tempNode.leftChild = largerTemp;
			largerTemp = tempNode.leftChild.rightChild;
			tempNode.leftChild.rightChild = tempNode.rightChild;
			tempNode = tempNode.leftChild;
		}
		return tempNode;
		
	}
	
	//----------------------------------------------------------------------------

	/*
	 *	Clears this tree.
	 */
	public void clear() {
		headNode = null;
	}
	
	//----------------------------------------------------------------------------
	/**
	 *	Checks to see if this class is managing a tree of Nodes.
	 *
	 *	@return true if tree of Nodes exists, false otherwise.
	 */
	private boolean isEmpty () {
		return (headNode == null);
	}
	
	//----------------------------------------------------------------------------
	/**
	 *	Converts the tree of Nodes, through itteration, into a String.
	 *	<p>
	 *	The order of the Node instances are printed in-order, pre-order, and
	 *	post-order.
	 *	<p>
	 *	Returns an emtpy string ("") if tree is empty.
	 *
	 *	@return String that contains all the values in the tree of Nodes.
	 */
	@Override
	public String toString() {
		if (!isEmpty())  {
			
			return "inOrder: "   + inOrder(headNode) + "\n" +
						 "preOrder: "  + preOrder(headNode) + "\n" +
						 "PostOrder: " + postOrder(headNode);
			
		}
		return "";
	}
	
	public String inOrder (Node<T> tempNode)  {
		if (tempNode != null) {
			return  inOrder(tempNode.leftChild) +
			tempNode + " " +
			inOrder(tempNode.rightChild);
		}
		return "";
	}
	
	public String preOrder (Node<T> tempNode)  {
		if (tempNode != null) {
			return  tempNode + " "+
			preOrder(tempNode.leftChild) +
			preOrder(tempNode.rightChild);
		}
		return "";
	}
	
	public String postOrder (Node<T> tempNode)  {
		if (tempNode != null) {
			return  inOrder(tempNode.leftChild) +
			inOrder(tempNode.rightChild) +
			tempNode+ " ";
		}
		return "";
	}
	
	//----------------------------------------------------------------------------
	/**
	 *	Tests this AVL class for possible errors.
	 *
	 *	@param args  command-line arguments in array form.
	 */
	public static void main (String... args){
		AVL<Integer> avl = new AVL<Integer>();
		System.out.println ("Inserting 6 \n");
		avl.insert(6);
		System.out.println ("Inserting 2 \n");
		avl.insert(2);
		System.out.println (avl + "\n");
		System.out.println ("Inserting 4 \n");
		avl.insert(4);
		System.out.println (avl + "\n");
		System.out.println ("Inserting 5 \n");
		avl.insert(5);
		System.out.println (avl + "\n");
		System.out.println ("Inserting 3 \n");
		avl.insert(3);
		System.out.println (avl + "\n");
		System.out.println ("Deleting 4 \n");
		avl.remove(4);
		System.out.println (avl + "\n");
		System.out.println ("Inserting 1 \n");
		avl.insert(1);
		System.out.println (avl + "\n");
	}
}
