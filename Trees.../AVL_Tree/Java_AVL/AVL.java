/*
 *	Created by Anton Velikodnyy & edited by Daniel Tellier on 6/27/17.
 *	CopyrightChild Â© 2017 Anton Velikodnyy. All rightChilds reserved.
 *	May be distributed for the use of teaching purposes.
 */

/**
 *	Container for the storage of data given.
 *	{@code Node} contains the pointer to the next instances in the tree of
 *	nodes generated by {@AVL}.
 *	<p>
 *	Note, requires {@code extends Number} because < and > are used to compare
 *	generic objects
 */
import java.util.Arrays;
class Node<U extends Number> {
	
	/**
	 *	Stores a generic immutable object.
	 */
	protected final U data;
	/**
	 *	Stores value for structure organization.
	 */
	protected int key;
	
	/**
	 *	Pointer to the leftChild child node of this node in the tree.
	 */
	protected  Node<U> leftChild;
	
	/**
	 *	Pointer to the rightChild child node of this node in the tree.
	 */
	protected  Node<U> rightChild;
	
	//----------------------------------------------------------------------------
	/**
	 *	Constructor of this {@code Node} class.
	 *
	 *	@param data  takes given object and stores in this Node.
	 */
	protected Node (U data) {
		this.data = data;
	}
	
	/**
	 *	Prints the data that is stored in this Node.
	 *
	 *	@return data in string form.
	 */
	@Override
	public String toString () {
		return data.toString();
	}
	
}

/**
 *	AVL is an object which creates and manages a tree of nodes stored
 *	in memory.
 *	<p>
 *	This class accepts any data type and can only directly access the
 *	head of the tree of nodes it manages.
 *	<p>
 *	Note, requires {@code extends Number} because < and > are used to compare
 *	generic objects
 */
public class AVL<T extends Number>  {
	
	
	//----------------------------------------------------------------------------
	/**
	 *	Stores pointer to starting Node of the tree.
	 */
	private Node<T> headNode = null;
	
	//----------------------------------------------------------------------------
	/**
	 *	Inserts Node into the tree.
	 *	<p>
	 *	If the tree is empty, the following actions occur:
	 *	<p><ol>
	 *	<li>Node instance created.
	 *	<li>This class' headNode becomes a pointer to this Node.
	 *	</ol><p>
	 *	If the tree is not empty, the following actions occur:
	 *	<p><ol>
	 *	<li>tempNode is used to traverse the tree until a place to insert a new Node
	 *	is found.
	 *	<li>A new Node is created and tempNode's child now points to this new Node
	 *	</ol><p>
	 *
	 *	@param data  is an Object, who's data-type matches the initially declared
	 *	data-type of this class, to be stored.
	 */
	/* Function to insert data */
	public void insert(T data)
	{
		headNode = insert(data, headNode);
	}
	/* Function to get key of node */
	private int key(Node<T> tempNode )
	{
		if (tempNode == null)
			return -1;
		else
			return tempNode.key;
	}
	/* Function to max of left/right node */
	private int max(int lhs, int rhs)
	{
		if (lhs > rhs)
			return lhs;
		else
			return rhs;
	}
	/* Function to insert data recursively */
	private Node<T> insert(T data, Node<T> t)
	{
		if (t == null)
			t = new Node<T>(data);
		else if (data.longValue() < t.data.longValue()){
			t.leftChild = insert( data, t.leftChild );
			if (key(t.leftChild) - key(t.rightChild) == 2)
				if (data.longValue() < t.leftChild.data.longValue())
					t = rotateWithLeftChild( t );
				else
					t = doubleWithLeftChild( t );
		}
		else if (data.longValue() > t.data.longValue()){
			t.rightChild = insert( data, t.rightChild);
			if (key( t.rightChild ) - key( t.leftChild ) == 2)
				if (data.longValue() > t.rightChild.data.longValue())
					t = rotateWithRightChild( t );
				else
					t = doubleWithRightChild( t );
		}
		else;  // Duplicate; do nothing
		t.key = max(key(t.leftChild), key(t.rightChild)) + 1;
		return t;
	}
	
	
	/* Rotate binary tree node with left child */
	private Node<T> rotateWithLeftChild(Node<T> k2)
	{
		Node<T> k1 = k2.leftChild;
		k2.leftChild = k1.rightChild;
		k1.rightChild = k2;
		k2.key = max( key( k2.leftChild ), key( k2.rightChild ) ) + 1;
		k1.key = max( key( k1.leftChild ), k2.key ) + 1;
		return k1;
	}
	/* Rotate binary tree node with right child */
	private Node<T> rotateWithRightChild(Node<T> k1)
	{
		Node<T> k2 = k1.rightChild;
		k1.rightChild = k2.leftChild;
		k2.leftChild = k1;
		k1.key = max( key( k1.leftChild ), key( k1.rightChild ) ) + 1;
		k2.key = max( key( k2.rightChild ), k1.key ) + 1;
		return k2;
	}
	/**
	 * Double rotate binary tree node: first left child
	 * with its right child; then node k3 with new left child */
	private Node<T> doubleWithLeftChild(Node<T> k3)
	{
		k3.leftChild = rotateWithRightChild( k3.leftChild );
		return rotateWithLeftChild( k3 );
	}
	/**
	 * Double rotate binary tree node: first right child
	 * with its left child; then node k1 with new right child */
	private Node<T> doubleWithRightChild(Node<T> k1)
	{
		k1.rightChild = rotateWithLeftChild( k1.rightChild );
		return rotateWithRightChild( k1 );
	}
	//----------------------------------------------------------------------------
	/**
	 *	Selects the Node to be removed, if it matches the search criteria given.
	 *	<p>
	 *	If isEmpty()} is false, the following actions occur.
	 *	<p></ol>
	 *	<li>tempNode is used to traverse the tree to find the match.
	 *	<li>Once match is found, removeNode is called.
	 *	<li>If no match is found, nothing happens.
	 *	</ol><p>
	 *
	 *	@param data  search criteria for the node to be removed.
	 */
	
	/* Function to delete data */
	public void remove(T data)
	{
		headNode = remove(data, headNode);
	}
	/* Function to delete data recursively */
	private Node<T> remove(T data, Node<T> t)
	{
		if (t.data.longValue() == data.longValue())
			t = removeNode (t);
		else if (data.longValue() < t.data.longValue()){
			t.leftChild = remove( data, t.leftChild );
			if (key(t.leftChild) - key(t.rightChild) == 2)
				if (data.longValue() < t.leftChild.data.longValue())
					t = rotateWithLeftChild( t );
				else
					t = doubleWithLeftChild( t );
		}
		else if (data.longValue() > t.data.longValue()){
			t.rightChild = remove( data, t.rightChild);
			if (key( t.rightChild ) - key( t.leftChild ) == 2)
				if (data.longValue() > t.rightChild.data.longValue())
					t = rotateWithRightChild( t );
				else
					t = doubleWithRightChild( t );
		}
		else;  // Duplicate; do nothing
		t.key = max(key(t.leftChild), key(t.rightChild)) + 1;
		return t;
	}
	
	//----------------------------------------------------------------------------
	/*
	 *	Removes the node from the tree.
	 *	<p>
	 *	The first if statement is to establish which child is to be of tempNode
	 *	needs to be removed. (note: Since erasing the pointer directly does not
	 *	break the original pointer)
	 *	<p>
	 *	Three scenarios arise from removing a node
	 *	<p><]ol>
	 *	<li>If only the rightNode of the child is null, then leftNode replaces
	 *	the child.
	 *	<li>If both are null, then child becomes null.
	 *	<li>If rightNode is not null, then the next largest Node must be found,
	 *	and is replaces the child.
	 *
	 *	@param tempNode  the parent of the node to be removed.
	 *	@param leftChild  boolean that determines if the leftChild or rightChild
	 *	is to be removed
	 */
	private Node<T> removeNode (Node<T> tempNode) {
		if (tempNode.rightChild == null) {
			if (tempNode.leftChild == null)
				tempNode = null;
			else
				tempNode = tempNode.leftChild;
		}
		else if (tempNode.leftChild == null)
			tempNode = tempNode.rightChild;
		else {
			Node<T> largerTemp = tempNode.rightChild;
			if (largerTemp.leftChild != null) {
				while  ( largerTemp.leftChild.leftChild != null)
					largerTemp = largerTemp.leftChild;
				largerTemp.leftChild.leftChild = tempNode.leftChild;
				tempNode.leftChild = largerTemp.leftChild;
				largerTemp.leftChild = tempNode.leftChild.rightChild;
				tempNode.leftChild.rightChild = tempNode.rightChild;
				tempNode = tempNode.leftChild;
			}
			else {
				System.out.println ("ok!\n");
				largerTemp.leftChild = tempNode.leftChild;
				System.out.println ("ok!\n");
				tempNode = tempNode.rightChild;
				System.out.println ("ok!\n");
			}
		}
		return tempNode;
			
	}
	
	/*
	 *	clears this tree.
	 */
	public void clear() {
		headNode = null;
	}
	
	//----------------------------------------------------------------------------
	/**
	 *	Checks to see if this class is managing a tree of Nodes.
	 *
	 *	@return true if tree of Nodes exists, false otherwise.
	 */
	private boolean isEmpty () {
		return (headNode == null);
	}
	
	//----------------------------------------------------------------------------
	/**
	 *	Converts the tree of Nodes, through itteration, into a String.
	 *	<p>
	 *	The order of the Node instances are printed in order.
	 *	<p>
	 *	Returns an emtpy string ("") if tree is empty.
	 *
	 *	@return String that contains all the values in the tree of Nodes.
	 */
	@Override
	public String toString() {
		if (!isEmpty())  {
			
			return inOrder(headNode);
		}
		return "";
	}
	
	public String inOrder (Node<T> tempNode)  {
		if (tempNode != null) {
			System.out.println (tempNode);
			return  inOrder(tempNode.leftChild) + " " +
			tempNode + " " +
			inOrder(tempNode.rightChild);
			
			
		}
		return "";
	}
	
	Display tree;
	public void display()
	{
		tree=new Display();
		display(headNode,1);
		tree.view();
	}
	private void display(Node<T> r, int position)
	{
		if (r != null){
			display(r.leftChild,position*2);
			tree.addElement(Integer.toString(r.data.intValue()),position);
			display(r.rightChild,position*2+1);
			position/=2;
		}
	}
	
	public class Display {
		private String[]number;
		private float spsaver;//keeps track where additional spaces do not need to be printed
		Display() {
			number=new String [1];                                                                  //calculates the number of lines the tree will have
			number[0]=" ";
		}
		/* Adds element to tree */
		public void addElement(String element,int position){
			int index=2*((int)(Math.ceil((Math.log(position+1)/Math.log(2))))-1)+1;                   //finds the line current number is in
			while(index>number.length-1){
				number=Arrays.copyOf(number,number.length+1);
				number[number.length-1]=" ";
				while(number.length>2&&number[number.length-1].length()<number[number.length-2].length())
					number[number.length-1]+=" ";
			}
			number[index]=number[index]+element;                                                    //places the current number into appropriate line in the string array
			for (int m=0;m<number.length;m++){                                                      //the small if statement inside the for loop saves lines from printing on last line
				if (m!=(index)){                                                                    //if curent line isnt the line in which the number is in, add equal amout of spaces to current line
					for (int n=0;n<element.length();n++){
						if ((m+1)<number.length && number[m+1].charAt(number[m+1].length()-1)=='/') //if line bellow the current line contains a '/', add '_' to current line
							number[m]=number[m]+"_";
						else if (number[m].charAt(number[m].length()-1)=='_')                       //if current line's final character is '_', add '_' to current line
							number[m]=number[m]+"_";
						else
							number[m]=number[m]+" ";                                                //adds a ' ' to current line if all other conditions are not met
					}
				}
			}
			if((position-1)%2==1 && position!=1&&element.length()>0)                        //if the current number has a parent, and current number is on the left in the tree, add '/' to currentl line
				number[index-1]=(number[index-1].substring(0,number[index-1].length()-1))+"/";
			if((position-1)%2==0 && position!=1&&element.length()>0){                       //same as previous comment except with '\', additionaly replaces the spaces above it with '_'
				if (number[index].length()==number[index-1].length()){
					number[index-1]=(number[index-1].substring(0,number[index-1].length()-element.length()))+
					"\\"+number[index-1].substring(number[index-1].length()-element.length()+1,number[index-1].length());
					for (int insert=1;(number[index-2].charAt(number[index-2].length()-((element.length()!=0)?element.length():1)-insert))==' ';insert++)
						number[index-2]=(number[index-2].substring(0,number[index-2].length()-element.length()-insert))+
						"_"+(number[index-2].substring(number[index-2].length()-(element.length())+1-insert,number[index-2].length()));
				}
				else{
					number[index-1]=number[index-1]+"\\";
					for (int insert=number[index-2].length()-1;Character.isWhitespace(number[index-2].charAt(insert));insert--){
						if (insert==number[index-2].length()-1)
							number[index-2]=(number[index-2].substring(0,insert))+"_";
						else
							number[index-2]=(number[index-2].substring(0,insert))+"_"+
							(number[index-2].substring(insert+1,number[index-2].length()));
					}
				}
			}
		}
		/* Adds element to tree */
		public void view(){
			int index;
			int index2;
			for(index=0;number[1].charAt(index)=='_'||number[1].charAt(index)==' ';index++);
			for(index2=number[1].length()-1;number[1].charAt(index2)=='_'||number[1].charAt(index2)==' ';index2--);
			index=((index+index2)/2);
			number[0]=number[0].substring(0,index)+"|";
			for(int k=0;k<number.length;k++ )
				System.out.println(number[k]);
			System.out.println();
			////
		}
	}
	
	//----------------------------------------------------------------------------
	/**
	 *	Tests this AVL class for possible errors.
	 *
	 *	@param args  command-line arguments in array form.
	 */
	public static void main (String... args){
		AVL<Integer> avl = new AVL<Integer>();
		avl.insert(5);
		avl.insert(2);
		System.out.println (avl + "!\n");
		avl.insert(6);
		avl.insert(3);
		System.out.println (avl + "?\n");
		System.out.println ("!\n");
		avl.insert(4);
		avl.display();
		System.out.println ("\n!!!\n");
		avl.insert(1);
		avl.display();
		avl.remove(5);
		avl.display();
		
		
	}
}
