/*
 *	Created by Anton Velikodnyy & edited by Daniel Tellier on 7/08/17.
 *	Copyright Â© 2017 Anton Velikodnyy. All rights reserved.
 *	May be distributed for the use of teaching purposes.
 */

#ifndef AVL_h
#define AVL_h

template <class T>
class AVL;
/**
 *	Container for the storage of data given.
 *	node contains the links to the left and right children node
 *	instances in the tree of nodes generated by AVL.
 */
template < class U >
class node {
public:
	
	/**
	 *	Constructor of this {@code node} class.
	 *
	 *	@param data, reference to the object given
	 *	@param next, sets another node as the next reference of this node.
	 *	@param prev, sets another Node as the prev raw pointer reference of this Node.
	 */
	node ( U const& data ) {
		this -> data = data;
		key = 0;
	}
	
	/**
	 *	Converts the data stored in this node to a printble string.
	 *
	 *	@return data in string form.
	 */
	std::string to_string () {
		return std::to_string ( data );
	}
	
	/**
	 *	Gets key value
	 */
	int get_key ()
	{	return key; }
	
	/**
	 *	Change this key value
	 */
	void change_key ( int key )
	{	this -> key = key;	}

	
private:
	
	/**
	 *	Grants access to AVL class
	 */
	template < class T >	friend class AVL;
	
	/**
	 *	Stores a generic object.
	 */
	U data;
	
	/**	
	 *	Stores key for easier organization
	 */
	int key;
	
	/**
	 *	Shorthand for unique ptr managing node.
	 */
	using node_ptr = std::unique_ptr < node >;
	
	/**
	 *	Ownership pointer to left node of the tree
	 */
	node_ptr left_child;
	
	/**
	 *	Ownership pointer to right node of the tree
	 */
	node_ptr right_child;

};

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
/**
 *	AVL is an object which creates and manages a tree of nodes stored
 *	in memory.
 *	<p>
 *	This class accepts any data type and can only initialy access the
 *	head  of the chain of nodes it manages, and then follows the through the
 *	tree to reach the leaf nodes.
 */
template < class T >
class AVL {
	
	
	/**
	 *	Shorthand for unique ptr managing node.
	 */
	using node_ptr = std::unique_ptr< node < T > >;
	
public:
	
	AVL() {}
	
	/**
	 *	Inserts given data into the tree.
	 */
	void insert ( T&& data );
	
	/**
	 *	Deletes node specified by user.
	 */
	void remove ( T&& data );
	
	/**
	 *	Finds the next largest node from the given node.
	 */
	node_ptr next_largest_node ( node_ptr& current );
	
	/**
	 *	Searches this tree for specific node.
	 */
	bool search_tree ( T&& data );
	
	/**
	 *	Deletes the entire tree.
	 */
	void delete_tree ()
	{		head_node_.reset();	}
	
	/**
	 *	Creates a string that the data stored in this tree.
	 */
	std::string to_string ()  {
		return "\nPre : " + pre_order_ (head_node_) + "\n" +
					 "In  : "		+ in_order_ (head_node_)	+ "\n" +
					 "Post: "		+ post_order_(head_node_) + "\n";
		
	}
	
private:
	
	/**
	 *	Ownership pointer to start of chain.
	 */
	node_ptr head_node_ = nullptr;
	
	/**
	 *	Recursively searches through this tree to find storage location of given data.
	 */
	bool insert_recur_ ( T const& , node_ptr& current );
	
	/**
	 *	Recursively searches through this tree to find storage location of given data.
	 */
	bool remove_recur_ ( T const& , node_ptr& );
	
	/**
	 *	Recursively searches through this tree to find storage location of given data.
	 */
	void remove_node_ ( node_ptr& );
	
	
	/*
	 *	Recursively searc hes through this tree to find storage location of given data.
	 */
	bool search_recur_ ( T const& , node_ptr& );
	
	/*
	 *	Decides which rotation to perform based on position the nodes are oriented in.
	 */
	void rotation_( node_ptr& , bool);
	
	/**
	 *	Rotates node and its right child
	 */
	void rotation_left_ ( node_ptr& , node_ptr& );
	
	/**
	 *	Rotates node and its left child
	 */
	void rotation_right_ ( node_ptr&, node_ptr& );
	
	/**
	 *	Ensures that this tree is balanced.
	 */
	void balance_node_ ( node_ptr& );

	/**
	 *	Recursively goes through the string and converts the tree to a string.
	 */
	std::string pre_order_ ( node_ptr const& );
	
	/**
	 *	Recursively goes through the string and converts the tree to a string.
	 */
	std::string in_order_ ( node_ptr const& );
	
	/**
	 *	Recursively goes through the string and converts the tree to a string.
	 */
	std::string post_order_ ( node_ptr const& );
};

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
/**
 *	Recieves data which needs to be placed into the tree.
 *	Basis case for recursive method.
 *
 *	@param data object given by user.
 */
template < class T >
void AVL<T>::insert ( T&& data )  {
	insert_recur_ ( std::forward<T> (data), head_node_ );
}

/**
 *	Recursively searches through this tree to find the given node.
 *
 *	@param data  object used as the matching key.
 *	@param current  reference to a node instance which is used to recurse through.
 *	@return boolean  true if node is created, false if otherwise.
 */
template < class T >
bool AVL<T>::insert_recur_ ( T const& data, node_ptr& current )  {
	if ( current )  {
		if ( current -> data > data ) {
			if ( insert_recur_ ( data, current -> left_child ) ) {
				balance_node_ ( current );
				return true;
			}
		}
		else if ( current -> data < data ) {
			if (insert_recur_( data, current -> right_child ))  {
				balance_node_ ( current );
				return true;
			}
		}
	}
	else  {
		current = std::make_unique < node < T > > ( data );
		return true;
	}
	return false;
}

//----------------------------------------------------------------------------
/**
 *	Recieves data which needs to be removed from this tree.
 *	Basis case for recursive method.
 *
 *	@param data  object used as the matching key.
 */
template < class T >
void AVL<T>::remove ( T&& data )  {
	this->remove_recur_( std::forward<T> ( data ), head_node_ );
}

/**
 *	Recursively searches through this tree to find the given node.
 *
 *	@param data  object used as the matching key.
 *	@param current  reference to a node instance which is used to recurse through.
 *	@return boolean  true if node is delelted, false if not found.
 */
template < class T >
bool AVL<T>::remove_recur_( const T& data, node_ptr& current )  {
	if ( current )  {
		if ( current -> data > data ) {
			if ( remove_recur_(data, current -> left_child ) ) {
				balance_node_ ( current );
				return true;
			}
		}
		else if ( current -> data < data ) {
			if ( remove_recur_ ( data, current -> right_child ) )  {
				balance_node_ ( current );
				return true;
			}
		}
		else  {
  		remove_node_ ( current );
  		return true;
		}
	}
	return false;
}

/**
 *	Removes the object given.
 *
 * @param current  the node to be removed
 */
template < class T >
void AVL<T>::remove_node_( node_ptr& current )  {
	if ( current ) {
		if ( !current -> left_child )
			current = std::move ( current -> right_child );
		else if ( !current -> right_child )
			current = std::move ( current -> left_child );
		else {
			auto temp						= next_largest_node ( current -> right_child );
			temp -> left_child	= std::move ( current -> left_child );
			temp -> right_child	= std::move ( current -> right_child );
			current							= std::move ( temp);
			balance_node_(current);
		}
	}
}

/** 
 *	Recursively searches through the tree to find the next largest node.
 * 
 *	@param current  node used for traversal of recursive methond.
 *	@return location of the largest node found.
 */
template < class T >
std::unique_ptr<node<T>> AVL<T>::next_largest_node ( node_ptr& current )  {
	if ( current -> left_child )  {
		auto temp = next_largest_node( current -> left_child );
		if ( temp )
			balance_node_ ( temp );
		return temp;
	}
	auto temp = std::move ( current );
	current   = std::move ( temp -> right_child );
	return  temp;
}

//----------------------------------------------------------------------------
/**
 *	Recieves data which used to find the node in this tree.
 *	Basis case for recursive method.
 *
 *	@param data  object used as the matching key.
 *	@return boolean  true if found, false otherwise.
 */
template < class T >
bool AVL<T>::search_tree ( T&& data )  {
	if (  this->search_recur_ ( std::forward<T> (data), head_node_ ) )
		return true;
	return false;
}

/**
 *	Recursively searches through this tree to find the given node.
 *
 *	@param data  object used as the matching key.
 *	@param current  reference to a node instance which is used to recurse through.
 *	@return boolean  true if node is found, false if not found.
 */
template < class T >
bool AVL<T>::search_recur_ ( T const& data, node_ptr& current )  {
	if ( current )  {
		if ( current -> data > data ) {
			if ( insert_recur_(data, current -> left_child ) ) {
				return true;
			}
		}
		else if ( current -> data < data ) {
			if ( insert_recur_( data, current -> right_child ) )  {
				return true;
			}
		}
		else return true;
	}
	return false;
}

//----------------------------------------------------------------------------
/** 
 *	Ensures that this tree is balanced.
 *	
 *	@param node  parent in question of balance
 */
template < class T >
void AVL<T>::balance_node_ ( node_ptr& current)  {
	auto height_left  = -1;
	auto height_right = -1;
	if ( current -> left_child )
		height_left = current -> left_child -> get_key ();
	if ( current -> right_child )
		height_right = current -> right_child -> get_key ();
	if ( height_left > height_right )
		current -> change_key ( height_left + 1 );
	else
		current -> change_key ( height_right + 1 );
	if ( height_left - height_right > 1 || height_right - height_left > 1 )  {
		rotation_( current, height_left > height_right );
	}
}

//----------------------------------------------------------------------------
template < class T >
void AVL<T>::rotation_ ( node_ptr& current, bool left_is_bigger)  {
	if (left_is_bigger)  {
		if ( current -> left_child -> right_child )  {
			rotation_left_ ( current -> left_child, current -> left_child -> right_child );
			rotation_right_ ( current, current -> left_child );
			balance_node_ ( current -> right_child );
			balance_node_ ( current->left_child );
		}
		else  {
			rotation_right_ ( current, current -> left_child );
			balance_node_ ( current -> right_child );
		}
	}
	else  {
		if ( current -> right_child -> left_child ) {
			rotation_right_ ( current -> right_child, current -> right_child -> left_child );
			rotation_left_	( current, current -> right_child );
			balance_node_ ( current -> right_child );
			balance_node_ ( current->left_child );
		}
		else  {
			rotation_left_ ( current, current->left_child );
			balance_node_ ( current->left_child );
		}
	}
}

template < class T >
void AVL<T>::rotation_left_ ( node_ptr& parent, node_ptr& child )  {
	std::swap ( child -> left_child, parent );
	std::swap ( child -> left_child -> right_child, parent );
}

template < class T >
void AVL<T>::rotation_right_ ( node_ptr& parent, node_ptr& child )  {
	std::swap ( child -> right_child, parent );
	std::swap ( child -> right_child -> left_child, parent );
}

//----------------------------------------------------------------------------
/**
 *	Recursively goes through the string and converts the tree to a string.
 *
 *	@param current  the node currently operating on.
 *	@return string  the string version of the tree.
 */
template < class T >
std::string AVL<T>::pre_order_(node_ptr const& current)  {
	if ( current )  {
		return
		current -> to_string() + " " +
		pre_order_(current -> left_child) +
		pre_order_(current -> right_child);
	}
	return "";
}

/**
 *	Recursively goes through the string and converts the tree to a string.
 *
 *	@param current  the node currently operating on.
 *	@return string  the string version of the tree.
 */
template < class T >
std::string AVL<T>::post_order_(node_ptr const& current)  {
	if ( current )  {
		return
		post_order_(current -> left_child) +
		post_order_(current -> right_child) +
		current -> to_string() + " ";
	}
	else
	return "";
}

/**
 *	Recursively goes through the string and converts the tree to a string.
 *
 *	@param current  the node currently operating on.
 *	@return string  the string version of the tree.
 */
template < class T >
std::string AVL<T>::in_order_(node_ptr const& current)  {
	if ( current )  {
		return
		in_order_(current -> left_child) +
		current -> to_string() + " " +
		in_order_(current -> right_child);
	}
	return "";
}




#endif /* AVL_h */
