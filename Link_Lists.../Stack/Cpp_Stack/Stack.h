//
//  Stack.h
//  Cpp_Stack
//
//  Created by Anton Velikodnyy on 7/18/17.
//  Copyright Â© 2017 Anton Velikodnyy. All rights reserved.
//

#ifndef Stack_h
#define Stack_h


#include <String>

/**
 *	Container for the storage of data given.
 *	{@code node} contains the links to the next {@code node}
 *	instances in the chain of nodes generated by {@code Stack}.
 */
template < class U >
class node {
public:
	
	/**
	 *	Shorthand for unique ptr managing node.
	 */
	using node_ptr = std::unique_ptr<node>;
	
	//----------------------------------------------------------------------------
	/**
	 *	Constructor of this {@code node} class.
	 *
	 *	@param data, reference to the object given
	 *	@param next, sets another node as the next reference of this node.
	 */
	node (U const& data, node_ptr &&next) {
		this->data = data;
		this->next = std::move(next);
	}
	
	/**
	 *	Converts the data stored in this node to a printble string.
	 *
	 *	@return data in string form.
	 */
	std::string to_string () {
		return std::to_string ( data );
	}
	
private:
	
	/**
	 *	Grants access to AVL class
	 */
	template < class T >	friend class Stack;
	
	/**
	 *	Stores a generic object.
	 */
	U data;
	
	/**
	 *	Ownership pointer to next node of the chain
	 */
	node_ptr next;
	
};

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
/**
 *	Stack is an object which creates and manages a chain of nodes stored
 *	in memory.
 *	<p>
 *	This class accepts any data type and can only directly access the
 *	head or tail of the chain of nodes it manages.
 */
template <class T>
class Stack {
	
public:
	
	Stack()
	{};
	
	/**
	 *	Inserts node instance at the end of the chain.
	 */
	void last_in (T &&data);
	
	/**
	 *	Removes node instance located at the end of the chain.
	 */
	void first_out();
	
	/*
	 *	Checks to see if this class is managing chain of nodes.
	 */
	bool is_empty();
	
	/**
	 *	Converts the chain of nodes, through itteration, into a string.
	 */
	std::string to_string ();
	
	
	
private:
	
	
	
	/**
	 *	Shorthand for a unique pointer to a node.
	 */
	using node_ptr = std::unique_ptr<node<T>>;
	
	/**
	 *	Ownership pointer to start of chain.
	 */
	node_ptr head_node = nullptr;
	
	/**
	 *	Converts the chain of node from head_node to tail_node, into a string.
	 */
	std::string to_string_forward (node_ptr const& current, std::string& list);
	
};


/**
 *	Inserts node instance at the end of the chain.
 *	<p>
 *	head_node becomes the new node that points to the location of the head_node.
 *
 *	@param data  is an Object, who's data-type matches the initially declared
 *	data-type of this class, to be referenced.
 */
template <class T>
void Stack<T>::last_in (T &&data) {
		head_node = std::make_unique<node<T>>(data,std::forward<node_ptr>(head_node));
}

//----------------------------------------------------------------------------
/**
 *	Removes node instance located at the end of the chain.
 *	<p>
 *	If the chain is empty, the following actions occur.
 *	<p></ol>
 *	<li>head_node becomes the next node.
 *	</ol><p>
 */
template <class T>
void Stack<T>::first_out () {
	if (!is_empty()) {
			head_node = std::move (head_node->next);
	}
}


//----------------------------------------------------------------------------
/**
 *	Checks to see if this class is managing a chain of nodes.
 *
 *	@return true if chain of nodes exists, false otherwise.
 */
template <class T>
bool Stack<T>::is_empty() {
	return !head_node;
}

//----------------------------------------------------------------------------
/**
 *	Converts the chain of nodes, through recursion, into a string.
 *	<p>
 *	The order of the node instances are printed from head_node to tail_node.
 *	Then again from tail_node to head_node.
 *	<p>
 *	Returns an emtpy string ("") if chain is empty.
 *
 *	@return String that contains all the values in the chain of Nodes.
 */
template <class T>
std::string Stack<T>::to_string() {
	std::string list = "";
	list = to_string_forward(head_node, list);
	return list;
}

/**
 *	Converts the chain of node from head_node to tail_node, into a string.
 *
 *	@param current  reference to the node who's data is being read into list
 *	@param list  string which stores the output of this chain
 *	@return string which has recursed through the chain.
 */
template <class T>
std::string Stack<T>::to_string_forward (node_ptr const& current, std::string& list) {
	if (current != nullptr)
		to_string_forward(current->next, list.append(current->to_string()));
	return list;
}
#endif /* Stack_h */
