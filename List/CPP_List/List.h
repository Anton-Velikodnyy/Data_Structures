/*
 *	Created by Anton Velikodnyy & edited by Daniel Tellier on 6/27/17.
 *	Copyright Â© 2017 Anton Velikodnyy. All rights reserved.
 *	May be distributed for the use of teaching purposes.
 */

#ifndef List_h
#define List_h
#include <String>

template < class U >
class node {
public:
	
	/**
	 *	Shorthand for unique ptr managing node.
	 */
	using node_ptr = std::unique_ptr<node>;
	
	//----------------------------------------------------------------------------
	/**
	 *	Constructor of this {@code node} class.
	 *
	 *	@param data, reference to the object given
	 *	@param next, sets another node as the next reference of this node.
	 *	@param prev, sets another Node as the prev raw pointer reference of this Node.
	 */
	node (U const& data, node_ptr &&next, node<U>* &&prev) {
		this->data = data;
		this->next = std::move(next);
		this->prev = std::move(prev);
	}
	
	/**
	 *	Converts the data stored in this node to a printble string.
	 *
	 *	@return data in string form.
	 */
	std::string to_string () {
		return std::to_string ( data );
	}
	
private:
	
	/**
	 *	Grants access to AVL class
	 */
	template < class T >	friend class List;
	
	/**
	 *	Stores a generic object.
	 */
	U data;

	/**
	 *	Ownership pointer to next node of the chain
	 */
	node_ptr next;
	
	/**
	 *	RAW pointer to the previous node in the chain
	 */
	node* prev	= nullptr;
	
};

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
/**
 *	List is an object which creates and manages a chain of nodes stored
 *	in memory.
 *	<p>
 *	This class accepts any data type and can only directly access the
 *	head or tail of the chain of nodes it manages.
 */
template <class T>
class List {

public:
	
	List()
		{};
	
	/**
	 *	Inserts node instance at the start of the chain.
	 */
	void first_in (T &&data);
	
	/**
	 *	Inserts node instance at the end of the chain.
	 */
	void last_in (T &&data);
	
	/**
	 *	Removes node instance located at the end of the chain.
	 */
	void first_out();
	
	/*
	 *	Removes node instance located at the start of the chain.
	 */
	void last_out();
	
	/*
	 *	Checks to see if this class is managing chain of nodes.
	 */
	bool is_empty();
	
	/**
	 *	Converts the chain of nodes, through itteration, into a string.
	 */
	std::string to_string ();
	

	
private:
	
	/**
	 *	Container for the storage of data given.
	 *	{@code node} contains the links to the next and previous {@code node}
	 *	instances in the chain of nodes generated by {@code List}.
	 */
	
	
	/**
	 *	Shorthand for a unique pointer to a node.
	 */
	using node_ptr = std::unique_ptr<node<T>>;
	
	/**
	 *	Ownership pointer to start of chain.
	 */
	node_ptr head_node = nullptr;
	
	/*
	 *	RAW pointer to the end of the chain.
	 */
	node<T>* tail_node = nullptr;
	
	/**
	 *	Converts the chain of node from head_node to tail_node, into a string.
	 */
	std::string to_string_forward (node_ptr const& current, std::string& list);
	
	/**
	 *	Converts the chain of node from tail_node to head_node, into a string.
	 */
	std::string to_string_backward (node<T>* const& current, std::string& list);
	
};



//----------------------------------------------------------------------------
/**
 *	Inserts node instance at the start of the chain.
 *	<p>
 *	If the chain is empty, the following actions occur:
 *	<p><ol>
 *	<li>node instance created.
 *	<li>This class' head_noode becomes the owner of this node.
 *	<li>This class' tail_node becomes a pointer to this head_node.
 *	</ol><p>
 *	If the chain is not empty, the following actions occur:
 *	<p><ol>
 *	<li>Reference to the prev pointer of head_node is created.
 *	<li>head_node becomes the owner of this new node.
 *	<li>This reference gains the link to this new node.
 *	</ol><p>
 *
 *	@param data  is an Object, who's data-type matches the initially declared
 *	data-type of this class, to be referenced.
 */
template	<class T> 
void List<T>::first_in(T &&data) {
	if (is_empty()) {
		head_node = std::make_unique<node<T>>(data,nullptr,nullptr);							//new node is created.
		tail_node = head_node.get();
	}
	else {
		auto& fresh_node = head_node->prev;
		head_node = std::make_unique<node<T>>(data,std::forward<node_ptr>(head_node),nullptr);
		fresh_node = head_node.get();
	}
}

/**
 *	Inserts node instance at the end of the chain.
 *	<p>
 *	If the chain is empty, the following actions occur:
 *	<p><ol>
 *	<li>node instance created.
 *	<li>This class' head_noode becomes the owner of this node.
 *	<li>This class' tail_node becomes a pointer to this head_node.
 *	</ol><p>
 *	If the chain is not empty, the following actions occur:
 *	<p><ol>
 *	<li>Reference to the next pointer of tail_node is created.
 *	<li>Reference gains ownership of this new node, with prev equating to tail_node
 *	<li>tail_node points to this new node.
 *	</ol><p>
 *
 *	@param data  is an Object, who's data-type matches the initially declared
 *	data-type of this class, to be referenced.
 */
template <class T>
void List<T>::last_in (T &&data) {
	if (is_empty()) {
		head_node = std::make_unique<node<T>>(data,nullptr,nullptr);
		tail_node = head_node.get();
	}
	else {
		auto& fresh_node = tail_node->next;
		tail_node->next = std::make_unique<node<T>>(data,nullptr,std::forward<node<T>*>(tail_node));
		tail_node = fresh_node.get();
	}
}

//----------------------------------------------------------------------------
/**
 *	Removes node instance located at the end of the chain.
 *	<p>
 *	If the chain is empty, the following actions occur.
 *	<p></ol>
 *	<li>If head_node and tail_node are the same, both are set to null.
 *	<li>Else tail_node is set to its prev pointer.
 *	<li>Then tail_node's next set to null, deleting the node instance at the
 *	end of the chain.
 *	</ol><p>
 */
template <class T>
void List<T>::first_out () {
	if (!is_empty()) {
		if (head_node.get() == tail_node){
			head_node = nullptr;
			tail_node = nullptr;
		}
		else {
			tail_node = std::move(tail_node->prev);
			tail_node->next = nullptr;
		}
	}
}

/**
 *	Removes node instance located at the start of the chain.
 *	<p>
 *	If the chain is not empty, the following actions occur.
 *	<p><ol>
 *	<li>If head_node and tail_node are the same, both are set to null.
 *	<li>Else the head_node is set to its prev pointer.
 *	<li>Then head_node's previous node is set to null, deleting the Node
 *	instance at the start of the chain.
 *	</ol><p>
 */
template <class T>
void List<T>::last_out () {
	if (!is_empty()) {
		if (head_node.get() == tail_node){
			head_node = nullptr;
			tail_node = nullptr;
		}
		else {
			head_node = std::move(head_node->next);
			head_node->prev = nullptr;
		}
	}
}

//----------------------------------------------------------------------------
/**
 *	Checks to see if this class is managing a chain of nodes.
 *
 *	@return true if chain of nodes exists, false otherwise.
 */
template <class T>
bool List<T>::is_empty() {
	return !head_node;
}

//----------------------------------------------------------------------------
/**
 *	Converts the chain of nodes, through recursion, into a string.
 *	<p>
 *	The order of the node instances are printed from head_node to tail_node.
 *	Then again from tail_node to head_node.
 *	<p>
 *	Returns an emtpy string ("") if chain is empty.
 *
 *	@return String that contains all the values in the chain of Nodes.
 */
template <class T>
std::string List<T>::to_string() {
	std::string list = "";
	list = to_string_forward(head_node, list);
	list = to_string_backward(tail_node, list.append("\n"));
	return list;
}

/**
 *	Converts the chain of node from head_node to tail_node, into a string.
 *
 *	@param current  reference to the node who's data is being read into list
 *	@param list  string which stores the output of this chain
 *	@return string which has recursed through the chain.
 */
template <class T>
std::string List<T>::to_string_forward (node_ptr const& current, std::string& list) {
	if (current != nullptr)
		to_string_forward(current->next, list.append(current->to_string()));
	return list;
}

/**
 *	Converts the chain of node from tail_node to head_node, into a string.
 *
 *	@param current  reference to the node who's data is being read into list
 *	@param list  string which stores the output of this chain
 *	@return string which has recursed through the chain.
 */
template <class T>
std::string List<T>::to_string_backward (node<T>* const& current, std::string& list) {
	if (current != nullptr)
		to_string_backward(current->prev, list.append(current->to_string()));
	return list;
}

#endif /* List_h */
