/*
 *	Created by Anton Velikodnyy & edited by Daniel Tellier on 7/08/17.
 *	Copyright © 2017 Anton Velikodnyy. All rights reserved.
 *	May be distributed for the use of teaching purposes.
 */

#include <iostream>

/*
 *	Created by Anton Velikodnyy & edited by Daniel Tellier on 7/08/17.
 *	Copyright © 2017 Anton Velikodnyy. All rights reserved.
 *	May be distributed for the use of teaching purposes.
 */

#ifndef BST_h
#define BST_h

template <class T>
class BST;
/**
 *	Container for the storage of data given.
 *	node contains the links to the left and right children node
 *	instances in the tree of nodes generated by BST.
 */
template <class U>
class node {
public:
	
	/**
	 *	Constructor of this {@code node} class.
	 *
	 *	@param data, reference to the object given
	 *	@param next, sets another node as the next reference of this node.
	 *	@param prev, sets another Node as the prev raw pointer reference of this Node.
	 */
	node (U &data) {
		this->data = data;
		key = 0;
	}
	
	/**
	 *	Converts the data stored in this node to a printble string.
	 *
	 *	@return data in string form.
	 */
	std::string to_string () {
		return std::to_string(data);
	}
	
private:
	
	/**
	 *	Grants access to BST class
	 */
	template < class T >	friend class BST;
	
	/**
	 *	Stores a generic object.
	 */
	U data;
	/**
	 *	Stores key for easier organization
	 */
	size_t key;
	
	/**
	 *	Shorthand for unique ptr managing node.
	 */
	using node_ptr = std::unique_ptr<node>;
	
	/**
	 *	Ownership pointer to left node of the tree
	 */
	node_ptr left_child;
	
	/**
	 *	Ownership pointer to right node of the tree
	 */
	node_ptr right_child;
	
};

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
/**
 *	BST is an object which creates and manages a tree of nodes stored
 *	in memory.
 *	<p>
 *	This class accepts any data type and can only initialy access the
 *	head  of the chain of nodes it manages, and then follows the through the
 *	tree to reach the leaf nodes.
 */
template <class T>
class BST {
	
	
	/**
	 *	Shorthand for unique ptr managing node.
	 */
	using node_ptr = std::unique_ptr<node<T>>;
public:
	
	BST() {}
	
	/**
	 *	Inserts given data into the tree.
	 */
	void insert_node ( T&& data );
	
	/**
	 *	Deletes node specified by user.
	 */
	void delete_node ( T&& data );
	
	/**
	 *	Finds the next largest node from the given node.
	 */
	node_ptr& next_largest_node ( node_ptr& current );
	
	/**
	 *	Searches this tree for specific node.
	 */
	bool search_tree ( T&& data );
	
	/**
	 *	Deletes the entire tree.
	 */
	void delete_tree ()
	{		head_node.reset();	}
	
	/**
	 *	Creates a string that the data stored in this tree.
	 */
	std::string to_string ()  {
		return pre_order (head_node) + "\n" + in_order (head_node) + "\n" + post_order(head_node) + "\n";
		
	}
	
private:
	
	/**
	 *	Ownership pointer to start of chain.
	 */
	node_ptr head_node = nullptr;
	
	/**
	 *	Recursively searches through this tree to find storage location of given data.
	 */
	node_ptr& search_node_ ( T const& data, node_ptr& current );
	
	/**
	 *	Recursively goes through the string and converts the tree to a string.
	 */
	std::string pre_order ( node_ptr const& current );
	
	/**
	 *	Recursively goes through the string and converts the tree to a string.
	 */
	std::string in_order ( node_ptr const& current );
	
	/**
	 *	Recursively goes through the string and converts the tree to a string.
	 */
	std::string post_order ( node_ptr const& current );
};

//----------------------------------------------------------------------------
/**
 *	Recieves data which needs to be placed into the tree.
 *	Calls search_node_ to find the location at which to insert in this tree.
 *	Creates new node instance at that location.
 *
 *	@param data object given by user.
 */
template < class T >
void BST<T>::insert_node ( T&& data )  {
auto& current = this->search_node_ ( std::forward<T> (data), head_node );
if (!current)
current = std::make_unique< node<T> > ( data );
}

/**
 *	Deletes the object, if found, in this tree.
 *
 *	@param data  object used as the matching key.
 */
template < class T >
void BST<T>::delete_node( T&& data )  {
	auto& current = this->search_node_ ( std::forward<T> (data), head_node );
	if ( current ) {
		if (!current->left_child)
			current = std::move (current -> right_child);
		else if (!current -> right_child)
			current = std::move (current -> left_child);
		else {
			auto& temp = next_largest_node(current -> right_child);
			temp -> left_child = std::move (current -> left_child);
			temp -> right_child= std::move (current -> right_child);
			current = std::move (temp);
		}
		
	}
}

/**
 *	Searches trhough the tree to find the next largest node.
 *
 *	@param current  node used for traversal of recursive methond.
 *	@return location of the largest node found.
 */
template < class T >
std::unique_ptr<node<T>>& BST<T>::next_largest_node ( node_ptr& current )  {
	if (current -> left_child)
		return next_largest_node(current -> left_child);
	return current;
}

/**
 *	Searches through the tree for given object.
 *
 *	@param data  object used as the matching key.
 *	@return boolean  true if found, false otherwise.
 */
template < class T >
bool BST<T>::search_tree( T&& data )  {
	if (  this->search_node_ ( std::forward<T> (data), head_node ) )
		return true;
	return false;
}


//----------------------------------------------------------------------------
/**
 *	Recursively searches through this tree to find the given node.
 *
 *	@param data  object used as the matching key.
 *	@param current  reference to a node instance which is used to recurse through.
 *	@return location  reference of the node found, nullptr if not found.
 */
template < class T >
std::unique_ptr<node<T>>& BST<T>::search_node_ ( T const& data, node_ptr& current )  {
	if ( current )  {
		if ( current -> data > data )
			return search_node_(data, current -> left_child );
		else if ( current -> data < data )
			return search_node_( data, current -> right_child );
		else
			return current;
	}
	return current;
}
/**
 *	Recursively goes through the string and converts the tree to a string.
 *
 *	@param current  the node currently operating on.
 *	@return string  the string version of the tree.
 */
template < class T >
std::string BST<T>::pre_order(node_ptr const& current)  {
	if ( current )  {
		return
		current -> to_string() + " " +
		in_order(current -> left_child) +
		in_order(current -> right_child);
	}
	return "";
}

/**
 *	Recursively goes through the string and converts the tree to a string.
 *
 *	@param current  the node currently operating on.
 *	@return string  the string version of the tree.
 */
template < class T >
std::string BST<T>::post_order(node_ptr const& current)  {
	if ( current )  {
		return
		in_order(current -> left_child) +
		in_order(current -> right_child) +
		current -> to_string() + " ";
	}
	return "";
}

/**
 *	Recursively goes through the string and converts the tree to a string.
 *
 *	@param current  the node currently operating on.
 *	@return string  the string version of the tree.
 */
template < class T >
std::string BST<T>::in_order(node_ptr const& current)  {
	if ( current )  {
		return
		in_order(current -> left_child) +
		current -> to_string() + " " +
		in_order(current -> right_child);
	}
	return "";
}




#endif /* BST_h */

int main(int argc, const char * argv[]) {
	std::unique_ptr<BST<int>> tree = std::make_unique<BST<int>>();
	auto i = 14;
	tree->insert_node(5);
	tree->insert_node(std::forward<decltype(i)> (i));
	tree->insert_node(6);
	tree->insert_node(1);
	tree->insert_node(2);
	tree->insert_node(3);
	if (tree->search_tree(3))
		std::cout<<"found 3\n";
	tree->delete_node(3);
	std::cout<<tree->to_string();
    return 0;
}
